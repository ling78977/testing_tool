// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_POINTSANNOTATION_FOXGLOVE_H_
#define FLATBUFFERS_GENERATED_POINTSANNOTATION_FOXGLOVE_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 2 &&
              FLATBUFFERS_VERSION_REVISION == 10,
             "Non-compatible flatbuffers version included");

#include "Color_generated.h"
#include "Point2_generated.h"
#include "Time_generated.h"

namespace foxglove {

struct PointsAnnotation;
struct PointsAnnotationBuilder;

/// Type of points annotation
enum PointsAnnotationType : uint8_t {
  PointsAnnotationType_UNKNOWN = 0,
  /// Individual points: 0, 1, 2, ...
  PointsAnnotationType_POINTS = 1,
  /// Closed polygon: 0-1, 1-2, ..., (n-1)-n, n-0
  PointsAnnotationType_LINE_LOOP = 2,
  /// Connected line segments: 0-1, 1-2, ..., (n-1)-n
  PointsAnnotationType_LINE_STRIP = 3,
  /// Individual line segments: 0-1, 2-3, 4-5, ...
  PointsAnnotationType_LINE_LIST = 4,
  PointsAnnotationType_MIN = PointsAnnotationType_UNKNOWN,
  PointsAnnotationType_MAX = PointsAnnotationType_LINE_LIST
};

inline const PointsAnnotationType (&EnumValuesPointsAnnotationType())[5] {
  static const PointsAnnotationType values[] = {
    PointsAnnotationType_UNKNOWN,
    PointsAnnotationType_POINTS,
    PointsAnnotationType_LINE_LOOP,
    PointsAnnotationType_LINE_STRIP,
    PointsAnnotationType_LINE_LIST
  };
  return values;
}

inline const char * const *EnumNamesPointsAnnotationType() {
  static const char * const names[6] = {
    "UNKNOWN",
    "POINTS",
    "LINE_LOOP",
    "LINE_STRIP",
    "LINE_LIST",
    nullptr
  };
  return names;
}

inline const char *EnumNamePointsAnnotationType(PointsAnnotationType e) {
  if (::flatbuffers::IsOutRange(e, PointsAnnotationType_UNKNOWN, PointsAnnotationType_LINE_LIST)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPointsAnnotationType()[index];
}

/// An array of points on a 2D image
struct PointsAnnotation FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PointsAnnotationBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TIMESTAMP = 4,
    VT_TYPE = 6,
    VT_POINTS = 8,
    VT_OUTLINE_COLOR = 10,
    VT_OUTLINE_COLORS = 12,
    VT_FILL_COLOR = 14,
    VT_THICKNESS = 16
  };
  /// Timestamp of annotation
  const foxglove::Time *timestamp() const {
    return GetStruct<const foxglove::Time *>(VT_TIMESTAMP);
  }
  foxglove::Time *mutable_timestamp() {
    return GetStruct<foxglove::Time *>(VT_TIMESTAMP);
  }
  /// Type of points annotation to draw
  foxglove::PointsAnnotationType type() const {
    return static_cast<foxglove::PointsAnnotationType>(GetField<uint8_t>(VT_TYPE, 0));
  }
  bool mutate_type(foxglove::PointsAnnotationType _type = static_cast<foxglove::PointsAnnotationType>(0)) {
    return SetField<uint8_t>(VT_TYPE, static_cast<uint8_t>(_type), 0);
  }
  /// Points in 2D image coordinates (pixels)
  const ::flatbuffers::Vector<::flatbuffers::Offset<foxglove::Point2>> *points() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<foxglove::Point2>> *>(VT_POINTS);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<foxglove::Point2>> *mutable_points() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<foxglove::Point2>> *>(VT_POINTS);
  }
  /// Outline color
  const foxglove::Color *outline_color() const {
    return GetPointer<const foxglove::Color *>(VT_OUTLINE_COLOR);
  }
  foxglove::Color *mutable_outline_color() {
    return GetPointer<foxglove::Color *>(VT_OUTLINE_COLOR);
  }
  /// Per-point colors, if `type` is `POINTS`, or per-segment stroke colors, if `type` is `LINE_LIST`.
  const ::flatbuffers::Vector<::flatbuffers::Offset<foxglove::Color>> *outline_colors() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<foxglove::Color>> *>(VT_OUTLINE_COLORS);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<foxglove::Color>> *mutable_outline_colors() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<foxglove::Color>> *>(VT_OUTLINE_COLORS);
  }
  /// Fill color
  const foxglove::Color *fill_color() const {
    return GetPointer<const foxglove::Color *>(VT_FILL_COLOR);
  }
  foxglove::Color *mutable_fill_color() {
    return GetPointer<foxglove::Color *>(VT_FILL_COLOR);
  }
  /// Stroke thickness in pixels
  double thickness() const {
    return GetField<double>(VT_THICKNESS, 0.0);
  }
  bool mutate_thickness(double _thickness = 0.0) {
    return SetField<double>(VT_THICKNESS, _thickness, 0.0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<foxglove::Time>(verifier, VT_TIMESTAMP, 4) &&
           VerifyField<uint8_t>(verifier, VT_TYPE, 1) &&
           VerifyOffset(verifier, VT_POINTS) &&
           verifier.VerifyVector(points()) &&
           verifier.VerifyVectorOfTables(points()) &&
           VerifyOffset(verifier, VT_OUTLINE_COLOR) &&
           verifier.VerifyTable(outline_color()) &&
           VerifyOffset(verifier, VT_OUTLINE_COLORS) &&
           verifier.VerifyVector(outline_colors()) &&
           verifier.VerifyVectorOfTables(outline_colors()) &&
           VerifyOffset(verifier, VT_FILL_COLOR) &&
           verifier.VerifyTable(fill_color()) &&
           VerifyField<double>(verifier, VT_THICKNESS, 8) &&
           verifier.EndTable();
  }
};

struct PointsAnnotationBuilder {
  typedef PointsAnnotation Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_timestamp(const foxglove::Time *timestamp) {
    fbb_.AddStruct(PointsAnnotation::VT_TIMESTAMP, timestamp);
  }
  void add_type(foxglove::PointsAnnotationType type) {
    fbb_.AddElement<uint8_t>(PointsAnnotation::VT_TYPE, static_cast<uint8_t>(type), 0);
  }
  void add_points(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<foxglove::Point2>>> points) {
    fbb_.AddOffset(PointsAnnotation::VT_POINTS, points);
  }
  void add_outline_color(::flatbuffers::Offset<foxglove::Color> outline_color) {
    fbb_.AddOffset(PointsAnnotation::VT_OUTLINE_COLOR, outline_color);
  }
  void add_outline_colors(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<foxglove::Color>>> outline_colors) {
    fbb_.AddOffset(PointsAnnotation::VT_OUTLINE_COLORS, outline_colors);
  }
  void add_fill_color(::flatbuffers::Offset<foxglove::Color> fill_color) {
    fbb_.AddOffset(PointsAnnotation::VT_FILL_COLOR, fill_color);
  }
  void add_thickness(double thickness) {
    fbb_.AddElement<double>(PointsAnnotation::VT_THICKNESS, thickness, 0.0);
  }
  explicit PointsAnnotationBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PointsAnnotation> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PointsAnnotation>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PointsAnnotation> CreatePointsAnnotation(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const foxglove::Time *timestamp = nullptr,
    foxglove::PointsAnnotationType type = foxglove::PointsAnnotationType_UNKNOWN,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<foxglove::Point2>>> points = 0,
    ::flatbuffers::Offset<foxglove::Color> outline_color = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<foxglove::Color>>> outline_colors = 0,
    ::flatbuffers::Offset<foxglove::Color> fill_color = 0,
    double thickness = 0.0) {
  PointsAnnotationBuilder builder_(_fbb);
  builder_.add_thickness(thickness);
  builder_.add_fill_color(fill_color);
  builder_.add_outline_colors(outline_colors);
  builder_.add_outline_color(outline_color);
  builder_.add_points(points);
  builder_.add_timestamp(timestamp);
  builder_.add_type(type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<PointsAnnotation> CreatePointsAnnotationDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const foxglove::Time *timestamp = nullptr,
    foxglove::PointsAnnotationType type = foxglove::PointsAnnotationType_UNKNOWN,
    const std::vector<::flatbuffers::Offset<foxglove::Point2>> *points = nullptr,
    ::flatbuffers::Offset<foxglove::Color> outline_color = 0,
    const std::vector<::flatbuffers::Offset<foxglove::Color>> *outline_colors = nullptr,
    ::flatbuffers::Offset<foxglove::Color> fill_color = 0,
    double thickness = 0.0) {
  auto points__ = points ? _fbb.CreateVector<::flatbuffers::Offset<foxglove::Point2>>(*points) : 0;
  auto outline_colors__ = outline_colors ? _fbb.CreateVector<::flatbuffers::Offset<foxglove::Color>>(*outline_colors) : 0;
  return foxglove::CreatePointsAnnotation(
      _fbb,
      timestamp,
      type,
      points__,
      outline_color,
      outline_colors__,
      fill_color,
      thickness);
}

inline const foxglove::PointsAnnotation *GetPointsAnnotation(const void *buf) {
  return ::flatbuffers::GetRoot<foxglove::PointsAnnotation>(buf);
}

inline const foxglove::PointsAnnotation *GetSizePrefixedPointsAnnotation(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<foxglove::PointsAnnotation>(buf);
}

inline PointsAnnotation *GetMutablePointsAnnotation(void *buf) {
  return ::flatbuffers::GetMutableRoot<PointsAnnotation>(buf);
}

inline foxglove::PointsAnnotation *GetMutableSizePrefixedPointsAnnotation(void *buf) {
  return ::flatbuffers::GetMutableSizePrefixedRoot<foxglove::PointsAnnotation>(buf);
}

inline bool VerifyPointsAnnotationBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<foxglove::PointsAnnotation>(nullptr);
}

inline bool VerifySizePrefixedPointsAnnotationBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<foxglove::PointsAnnotation>(nullptr);
}

inline void FinishPointsAnnotationBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<foxglove::PointsAnnotation> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedPointsAnnotationBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<foxglove::PointsAnnotation> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace foxglove

#endif  // FLATBUFFERS_GENERATED_POINTSANNOTATION_FOXGLOVE_H_
