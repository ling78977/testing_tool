#include <foxglove/websocket/base64.hpp>
#include <foxglove/websocket/server_factory.hpp>
#include <foxglove/websocket/websocket_notls.hpp>
#include <foxglove/websocket/websocket_server.hpp>

#include "Pose_generated.h"

// #include "dds/dds.h"
#include "flatbuffers/flatbuffers.h"
// #include "sensor_img.h"
#include "chassis_data_type.h"
#include "sensor_imu_type.h"
// #include <atomic>
#include <chrono>
#include <cmath>
// #include <csignal>
#include <fstream>
#include <iostream>
#include <memory>
#include <queue>
// #include <thread>
#include "ddssubscriber.hpp"
#include <unordered_set>

static uint64_t nanosecondsSinceEpoch() {
  return uint64_t(std::chrono::duration_cast<std::chrono::nanoseconds>(
                      std::chrono::system_clock::now().time_since_epoch())
                      .count());
}
// Adapted from https://flatbuffers.dev/flatbuffers_guide_use_cpp.html
static std::string getFileContents(std::string_view path) {
  std::cout << "Attempting to open file: " << path << std::endl;
  std::ifstream infile;
  infile.open(path.data(), std::ios::binary | std::ios::in);
  if (!infile) {
    throw std::runtime_error("Could not open file " + std::string(path));
  }

  infile.seekg(0, std::ios::end);
  int length = infile.tellg();
  infile.seekg(0, std::ios::beg);
  std::string result(length, '\0');
  infile.read(result.data(), length);
  infile.close();
  return result;
}
int main(int argc, char **argv) {
  std::vector<std::string> args(argv, argv + argc);
  const std::string poseBfbsPath = "autogenerated_flatbuffers_bfbs/Pose.bfbs";
  std::ifstream poseFile(poseBfbsPath);
  if (!poseFile) {
    std::cerr << "Error: " << poseBfbsPath << " not found" << std::endl;
    return 1;
  }

  const auto logHandler = [](foxglove::WebSocketLogLevel, char const *msg) {
    std::cout << msg << std::endl;
  };
  foxglove::ServerOptions serverOptions;
  auto server =
      foxglove::ServerFactory::createServer<websocketpp::connection_hdl>(
          "C++ FlatBuffers example server", logHandler, serverOptions);
  foxglove::ServerHandlers<foxglove::ConnHandle> hdlrs;
  hdlrs.subscribeHandler = [&](foxglove::ChannelId chanId,
                               foxglove::ConnHandle clientHandle) {
    const auto clientStr = server->remoteEndpointString(clientHandle);
    std::cout << "Client " << clientStr << " subscribed to " << chanId
              << std::endl;
  };
  hdlrs.unsubscribeHandler = [&](foxglove::ChannelId chanId,
                                 foxglove::ConnHandle clientHandle) {
    const auto clientStr = server->remoteEndpointString(clientHandle);
    std::cout << "Client " << clientStr << " unsubscribed from " << chanId
              << std::endl;
  };
  server->setHandlers(std::move(hdlrs));
  server->start("0.0.0.0", 8765);

  // IMU通道
  const auto poseChannelIds = server->addChannels({{
      .topic = "imu_data",
      .encoding = "flatbuffer",
      .schemaName = "foxglove.Pose",
      .schema = foxglove::base64Encode(
          getFileContents("autogenerated_flatbuffers_bfbs/Pose.bfbs")),
  }});
  foxglove::ChannelId imuChanId;
  imuChanId = poseChannelIds[0];

  DDSSubscriber subscriber;
  subscriber.create_subscriber<imu_data_t>(
      "dds_imu", &imu_data_t_desc,
      [&](const imu_data_t &data, const dds_sample_info_t &info) {
        flatbuffers::FlatBufferBuilder imuBuilder;
        imuBuilder.ForceDefaults(true);
        auto position =
            foxglove::CreateVector3(imuBuilder, data.gx, data.gy, data.gz);
        auto orientation = foxglove::CreateQuaternion(imuBuilder, 0, 0, 0, 0);
        auto imuPose = foxglove::CreatePose(imuBuilder, position, orientation);

        imuBuilder.Finish(imuPose);

        // 验证并发送IMU数据
        auto imuVerifier = flatbuffers::Verifier(imuBuilder.GetBufferPointer(),
                                                 imuBuilder.GetSize());
        if (foxglove::VerifyPoseBuffer(imuVerifier)) {
          const auto now = nanosecondsSinceEpoch();
          server->broadcastMessage(imuChanId, now,
                                   imuBuilder.GetBufferPointer(),
                                   imuBuilder.GetSize());
        } else {
          std::cerr << "IMU Flatbuffer verification failed" << std::endl;
        }
      });
  subscriber.create_subscriber<wheel_pos_data_t>(
      "odom_topic", &wheel_pos_data_t_desc,
      [](const wheel_pos_data_t &data, const dds_sample_info_t &info) {
        // 处理另一种类型的数据
        std::cout << "odom_data: " << data.wl_sl << " " << data.wl_sm << " "
                  << data.wl_sr << " " << data.wr_sl << std::endl;
      });
  subscriber.run();
  server->removeChannels({imuChanId});
  server->stop();

  return 0;
}